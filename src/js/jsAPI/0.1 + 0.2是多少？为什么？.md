##### 0.1 + 0.2、0.1 + 0.3 和 0.1 X 0.2 分别等于多少？并解释下为什么？

[参考趁你还年轻 233 博客](https://www.jianshu.com/p/d6b81e4e25e3)

> `EcmaScrpt` 规范定义 `Number` 的类型遵循了 `IEEE754-2008` 中的 `64` 位浮点数规则定义的小数后的有效位数至多为 `52` 位导致计算出现精度丢失问题！

- 原因分析：如果不限精度，`0.1` 转化为二进制应该为 `0.000110011001100110011（0011`）无限循环，限制精度之后循环的数字被裁剪，因此就出现了精度丢失的情况。`0.2` 转化为二进制也是无限循环，同样会精度丢失。

- 通过上面的分析：
  `0.1 + 0.2 = 0.30000000000000004`,
  `0.1 + 0.3 = 0.4`，

  `0.1  * 0.2 = 0.020000000000000004 `


建议先阅读这篇文章了解 IEEE 754 ：[硬核基础二进制篇（一）0.1 + 0.2 != 0.3 和 IEEE-754 标准](https://juejin.cn/post/6940405970954616839)。 
再阅读这篇文章了解如何运算：[0.1 + 0.2 不等于 0.3？为什么 JavaScript 有这种“骚”操作？](https://juejin.cn/post/6844903680362151950)。 

原因总结：

- `进制转换` ：js 在做数字计算的时候，0.1 和 0.2 都会被转成二进制后无限循环 ，但是 js 采用的 IEEE 754 二进制浮点运算，最大可以存储 53 位有效数字，于是大于 53 位后面的会全部截掉，将导致精度丢失。
- `对阶运算` ：由于指数位数不相同，运算时需要对阶运算，阶小的尾数要根据阶差来右移（`0舍1入`），尾数位移时可能会发生数丢失的情况，影响精度。

解决方案：
1、Number.EPSILON:
```js
function isEqual(a, b) {
  return Math.abs(a - b) < Number.EPSILON;
}

console.log(isEqual(0.1 + 0.2, 0.3)); // true
```