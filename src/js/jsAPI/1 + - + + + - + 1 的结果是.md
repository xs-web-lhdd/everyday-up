##### 1 + - + + + - + 1 的结果是？

```js
// 2
解析：
+/- 号在 JavaScript 通常有三种用途：

普通加减法: 二元运算符
++/--: 自增自减，一元运算符
+/-: 正负，一元运算符

上面表达式中没有涉及自增与自减的情况，一元运算符的优先级大于二元运算符，上述表达式执行顺序为：
1 + (- (+ (+ (+ (- (+ 1)))))) ----> 1 + 1 = 2
```

[运算符优先级 - JavaScript | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#汇总表)

一道包含优先级的综合题目：

```js
function Foo(){
    getName = function(){ console.log(1); };
    return this;
}
Foo.getName = function(){ console.log(2); };
Foo.prototype.getName = function(){ console.log(3); };
var getName = function(){ console.log(4); };
function getName(){ console.log(5) };

Foo.getName();         
getName();        
Foo().getName();
getName();        
new Foo.getName();
new Foo().getName();
```

##### 解析：

> [参考文档: 运算符优先级](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)

1. 预编译

```js
GO = {
    Foo: fn(Foo),
    getName: function getName(){ console.log(5) };
}
```

2. 分析后续执行

+ `Foo.getName()`: 执行Foo上的getName方法，打印2

+ `getName()`: 执行GO中的getName方法，打印4

+ `Foo().getName()`

  + `Foo()`执行

  ```js
  // 修改全局GO的getName为function(){ console.log(1); }
  getName = function(){ console.log(1) }
  // Foo为默认绑定，this -> window
  // return window
  return this
  ```

  + `Foo().getName()`: 执行window.getName()，打印1

+ `getName()`: 执行GO中的getName，打印1

3. 分析后面三个打印结果之前，先补充一些运算符优先级方面的知识(图源：[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence))
   ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be30dd2c4b8e4acca313a88a5d11acce~tplv-k3u1fbpfcp-watermark.awebp)
   从上图可以看到，部分优先级如下：**new(带参数列表) = 成员访问 = 函数调用 > new(不带参数列表)**
4. `new Foo.getName()`

首先从左往右看：`new Foo`属于不带参数列表的new(优先级**19**)，`Foo.getName`属于成员访问(优先级**20**)，`getName()`属于函数调用(优先级**20**)，同样优先级遵循从左往右执行。

   + `Foo.getName`执行，获取到Foo上的`getName`属性
   + 此时原表达式变为`new (Foo.getName)()`，`new (Foo.getName)()`为带参数列表(优先级**20**)，`(Foo.getName)()`属于函数调用(优先级**20**)，从左往右执行
   + `new (Foo.getName)()`执行，打印`2`，并返回一个以`Foo.getName()`为构造函数的实例

> 这里有一个误区：很多人认为这里的`new`是没做任何操作的的，执行的是函数调用。那么如果执行的是`Foo.getName()`，调用返回值为`undefined`，`new undefined`会发生报错，并且我们可以验证一下该表达式的返回结果。

```js
console.log(new Foo.getName())
// 2
// Foo.getName {}
```

可见在成员访问之后，执行的是**带参数列表格式的new**操作。

5. `new Foo().getName()`
   + 同`步骤4`一样分析，先执行`new Foo()`，返回一个以`Foo`为构造函数的实例
   + `Foo`的实例对象上没有`getName`方法，沿原型链查找到`Foo.prototype.getName`方法，打印`2`
6. `new new Foo().getName()`

从左往右分析: 第一个new不带参数列表(优先级**19**)，`new Foo()`带参数列表(优先级**20**)，剩下的成员访问和函数调用优先级都是**20**

   + `new Foo()`执行，返回一个以`Foo`为构造函数的实例
   + 在执行成员访问，`Foo`实例对象在`Foo.prototype`查找到`getName`属性
   + 执行`new (new Foo().getName)()`，返回一个以 `Foo.prototype.getName()`为构造函数的实例，打印`2`

7. **`new Foo.getName()` 与 `new new Foo().getName()`区别：**

 + `new Foo.getName()`的构造函数是`Foo.getName`
 + `new new Foo().getName()`的构造函数为`Foo.prototype.getName`

测试结果如下:

```js
foo1 = new Foo.getName()
foo2 = new new Foo().getName()
console.log(foo1.constructor)
console.log(foo2.constructor)
```

输出结果：

```js
2
3
ƒ (){ console.log(2); }
ƒ (){ console.log(3); }
```

通过这一步比较应该能更好的理解上面的执行顺序。

**答案**

```js
2
4
1
1
2
3
3
```
