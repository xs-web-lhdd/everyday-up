##### 35、深入解析 EventLoop 和浏览器渲染、帧动画、空闲回调的关系：
[简书佬！结论清晰](https://www.jianshu.com/p/ba5828330aec)
[字节佬讲解！好难啊---原理解析](https://zhuanlan.zhihu.com/p/142742003)
这篇文章太硬核了，绷不住了

##### 问题：
1、浏览器在每一轮Event Loop事件循环中都会去渲染屏幕吗？
2、requestAnimationFrame在哪个阶段执行，是在渲染前还是渲染后？是在微任务执行前还是执行后？
3、requestIdleCallback在哪个阶段执行，是在渲染前还是渲染后？ 是在微任务执行前还是执行后？


来看时机：
1、从task任务队列中取第一个task（比如setTimeout、setIntervel的回调，也可以将同一轮循环中的所有同步代码看作是一个宏任务），执行它。
2、执行微任务队列里的所有微任务。
3、浏览器判断是否更新渲染屏幕，如果需要重新绘制，则执行步骤4-13，如果不需要重新绘制，则流程回到步骤1，这样不断循环。
4、触发resize、scroll事件，建立媒体查询（执行一个任务中如果生成了微任务，则执行完任务该后就会执行所有的微任务，然后再执行下一个任务）。
5、建立css动画（执行一个任务中如果生成了微任务，则执行完该任务后就会执行所有的微任务，然后再执行下一个任务）。
6、执行requestAnimationFrame回调（执行一个任务中如果生成了微任务，则执行完该任务后就会执行所有的微任务，然后再执行下一个任务）。
7、执行 IntersectionObserver 回调（执行一个任务中如果生成了微任务，则执行完该任务后就会执行所有的微任务，然后再执行下一个任务）。
8、更新渲染屏幕。
9、浏览器判断当前帧是否还有空闲时间，如果有空闲时间，则执行步骤10-12。
10、从 requestIdleCallback回调函数队列中取第一个，执行它。
11、执行微任务队列里的所有微任务。
12、流程回到步骤9，直到requestIdleCallback回调函数队列清空或当前帧没有空闲时间。
流程回到步骤1，这样不断循环。


解答上面问题：
1、不一定。如果不需要渲染屏幕那么就不会渲染
2、requestAnimationFrame 是在渲染前执行，在微任务之后执行
> 在渲染前执行原因：因为 rAF（requestAnimationFrame） 是官方推荐的用来做一些流畅动画所应该使用的 API，做动画不可避免的会去更改 DOM，而如果在渲染之后再去更改 DOM，那就只能等到下一轮渲染机会的时候才能去绘制出来了，会卡顿，这显然是不合理的。
3、requestIdleCallback是在浏览器渲染后有空闲时间时执行，如果requestIdleCallback设置了第二个参数timeout，则会在超时后的下一帧强制执行。在微任务执行后执行


##### 为什么 requestAnimationFrame 是在浏览器渲染之前执行？
- 在渲染前执行原因：因为 rAF（requestAnimationFrame） 是官方推荐的用来做一些流畅动画所应该使用的 API，做动画不可避免的会去更改 DOM，而如果在渲染之后再去更改 DOM，那就只能等到下一轮渲染机会的时候才能去绘制出来了，会卡顿，这显然是不合理的。


##### 照你这样讲述 resize 和 scroll 意思是微任务之后 派发 的吗？
不是！是立即执行缩放和滚动，但是回调函数是等到微任务执行之后才执行的。
解释：
对于resize 和 scroll来说，并不是到了这一步才去执行滚动和缩放，那岂不是要延迟很多？浏览器当然会立刻帮你滚动视图，根据CSSOM 规范所讲，浏览器会保存一个 pending scroll event targets，等到事件循环中的 scroll这一步，去派发一个事件到对应的目标上，驱动它去执行监听的回调函数而已。resize也是同理。