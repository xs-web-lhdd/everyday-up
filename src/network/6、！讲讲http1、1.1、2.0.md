##### http1、1.1、2.0 ：
浏览器。。。

##### http1.1的串行请求是谁控制的，协议还是客户端的问题:

#### 你刚刚说队头阻塞？那HTTP1.1 如何解决 HTTP 的队头阻塞问题？
- 并发连接
对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。在RFC2616规定过客户端最多并发 2 个连接，不过事实上在现在的浏览器标准中，这个上限要多很多，Chrome 中是 6 个。
但其实，即使是提高了并发连接，还是不能满足人们对性能的需求。
- 域名分片
一个域名不是可以并发 6 个长连接吗？那我就多分几个域名。
比如 content1.sanyuan.com 、content2.sanyuan.com。
这样一个sanyuan.com域名下可以分出非常多的二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了，事实上也更好地解决了队头阻塞的问题。

#### 那 http2 怎么解决呢？
http1.1 用`并发连接`和`域名分片`的方式来解决这个问题，但这并没有真正从 HTTP 本身的层面解决问题，只是增加了 TCP 连接，分摊风险而已。而且这么做也有弊端，多条 TCP 连接`会竞争有限的带宽`，让`真正优先级高的请求不能优先处理`。

而 HTTP/2 便从 HTTP 协议本身解决了队头阻塞问题。注意，这里并不是指的TCP队头阻塞，而是HTTP队头阻塞，两者并不是一回事。`TCP 的队头阻塞是在数据包层面，单位是数据包，前一个报文没有收到便不会将后面收到的报文上传给 HTTP`，而HTTP 的队头阻塞是在 `HTTP 请求-响应层面，前一个请求没处理完，后面的请求就要阻塞住`。两者所在的层次不一样。

首先，HTTP/2 认为`明文传输对机器`而言太麻烦了，`不方便计算机的解析`，因为对于文本而言会有多义性的字符，比如回车换行到底是内容还是分隔符，在内部需要用到状态机去识别，效率比较低。于是 HTTP/2 干脆把`报文全部换成二进制格式`，全部传输01串，方便了机器的解析。
原来Headers + Body的报文格式如今被拆分成了一个个二进制的帧，用Headers帧存放头部字段，Data帧存放请求体数据。分帧之后，服务器看到的不再是一个个完整的 HTTP 请求报文，而是一堆乱序的二进制帧。这些二进制帧不存在先后关系，因此也就不会排队等待，也就没有了 HTTP 的队头阻塞问题。
通信双方都可以给对方发送二进制帧，这种`二进制帧的双向传输的序列，也叫做流(Stream)`。HTTP/2 用流来在一个 TCP 连接上来进行多个数据帧的通信，这就是`多路复用`的概念。
可能你会有一个疑问，既然是乱序首发，那最后如何来处理这些乱序的数据帧呢？
首先要声明的是，所谓的乱序，指的是`不同 ID 的 Stream 是乱序的`，但同一个 Stream ID 的帧一定是按顺序传输的。二进制帧到达后对方会将 Stream ID 相同的二进制帧组装成完整的请求报文和响应报文。当然，在二进制帧当中还有其他的一些字段，实现了`优先级`和`流量控制`等功能

#### HTTP2.0分帧，服务端接收后怎么组装？



#### HTTP/2 有哪些改进？
- 头部压缩
- 多路复用
- 服务器推送
- 设置请求优先级

##### 服务器推送
另外值得一说的是 HTTP/2 的服务器推送(Server Push)。在 HTTP/2 当中，服务器已经不再是完全被动地接收请求，响应请求，它也能新建 stream 来给客户端发送消息，当 TCP 连接建立之后，比如浏览器请求一个 HTML 文件，服务器就可以在返回 HTML 的基础上，将 HTML 中引用到的其他资源文件一起返回给客户端，减少客户端的等待。


##### 刚刚提到http2有服务器推送功能。http2与websocet都有服务器推送的功能，那么websocket会被http2取代吗？为什么？
不会的。
因为HTTP2的推送是浏览器和服务端之间的一个推送的概念，比如我在HTTP2中请求 a.html 服务端会自动把css和一些其他资源一并返回，
而websocket的推送是有API的，可以在客户端手动控制的，这就是区别。


##### 说说http中的缓存机制?


##### 知道HTTP1.X是什么分帧吗，知道二进制分帧和普通分帧的区别吗，知道二进制分帧是怎么个分帧呢?

二进制分帧把数据转换成一个个带有请求 ID 编号的帧，通过协议栈把这些帧发送给服务器。

##### 头部压缩的原理？
请求体一般会有响应的压缩编码过程，通过`Content-Encoding`头部字段来指定，但你有没有想过头部字段本身的压缩呢？当请求字段非常复杂的时候，尤其对于 GET 请求，请求报文几乎全是请求头，这个时候还是存在非常大的优化空间的。HTTP/2 针对头部字段，也采用了对应的压缩算法——`HPACK`，对请求头进行压缩。

HPACK 算法是专门为 HTTP/2 服务的，它主要的亮点有两个：

1、首先是在服务器和客户端之间建立哈希表，将用到的字段存放在这张表中，那么在传输的时候对于之前出现过的值，只需要把索引(比如0，1，2，...)传给对方即可，对方拿到索引查表就行了。这种传索引的方式，可以说让请求头字段得到极大程度的精简和复用。
2、其次是对于整数和字符串进行哈夫曼编码，哈夫曼编码的原理就是先将所有出现的字符建立一张索引表，然后让出现次数多的字符对应的索引尽可能短，传输的时候也是传输这样的索引序列，可以达到非常高的压缩率。

> 注意：HTTP/2 当中废除了起始行的概念，将起始行中的请求方法、URI、状态码转换成了头字段，不过这些字段都有一个":"前缀，用来和其它请求头区分开。

##### 问我多路复用的TCP连接数？
HTTP/2下：⼀个域名只使⽤⼀个TCP⻓连接


##### 每一次http请求都会建立TCP连接吗？
不会。
HTTP/1.1中增加了持久连接的⽅法，它的特点是在⼀个TCP连接上可以传输多个HTTP请求，只要浏览器或者服务器没有明确断开连接，那么该TCP连接会⼀直保持。
持久连接在HTTP/1.1中是默认开启的，所以你不需要专⻔为了持久连接去HTTP请求头设置信息，如果你不想要采⽤持久连接，可以在HTTP请求头中加上Connection: close。⽬前浏览器中对于同⼀个域名，默认允许同时建⽴6个TCP持久连接。（http1.1 是 6个，后面 http2 中废除了只有一个）
