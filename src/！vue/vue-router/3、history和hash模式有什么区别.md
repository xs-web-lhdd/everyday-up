### 3、history 和 hash 有什么区别？
[深入了解前端路由 hash 与 history 差异 --- 微信公众号：高级前端进阶](https://mp.weixin.qq.com/s/qf1MxeR2759G1N4p-eH27A)


1、简单介绍 Vue Router
Vue Router 是 Vue.js[1] 官方的路由插件，它和 Vue.js[2] 是深度集成的，适合用于构建单页面应用。vue的单页面应用是基于路由和组件的，路由用于设定访问路径，并`将路径和组件映射起来`。传统的页面应用，是用一些超链接来实现页面切换和跳转的。在 vue-router 单页面应用中，则是`路径之间的切换`，也就是`组件的切换`。路由模块的本质 就是`建立起url和页面之间的映射关系`。
至于我们为什么不能用a标签，这是因为用Vue做的都是单页应用，就相当于只有一个主的 index.html 页面，所以你写的 标签是不起作用的，你必须使用 vue-router 来进行管理。

2、 Router 实现原理
在了解路由模式前，我们要先清楚，vue-roter 的实现原理是怎样的，什么是单页面应用，特点是什么，这样更容易加深对路由的理解。
SPA 单页面及应用方式:`单一页面应用程序，只有一个完整的页面；它在第一次加载页面时,就将唯一完整的 html 页面和所有其余页面组件一起下载下来，这样它在切换页面时，不会加载整个页面，而是只更新某个指定的容器中内容。`
单页面应用(SPA)的核心之一是: `更新视图而不重新请求页面。`
路由器对象底层实现的三大步骤即`(1)监视地址栏变化；(2)查找当前路径对应的页面组件；(3)将找到的页面组件替换到 router-vieW 的位置。`
vue-router 在实现单页面前端路由时，提供了两种方式：Hash 模式和 History 模式；vue2 是`根据 mode 参数`来决定采用哪一种方式，vue3 则`是 history 参数`，下面我们将围绕这个属性进行进一步了解。

3、特点
路由跳转不需要重新加载页面。
不带 # 在大部分人看来要比 hash 路由好看许多。
兼容性没有 hash 好，会在下面展开说明

4、生产环境问题及解决
当我们把 history 项目部署到服务器中后,此时我们在浏览器输入一个网址(比如是 www.test.com[3] ), 此时会经过 dns 解析，拿到 ip 地址后根据 ip 地址向该服务器发起请求,服务器接受到请求后,然后返回相应的结果(html,css,js)。如果我们在前端设置了重定向，此时页面会进行跳转到 www.test.com/home[4] ,在前端会进行匹配对应的组件然后将其渲染到页面上。此时如果我们`刷新页面的话，浏览器会发送新的请求` www.test.com/home[5], 如果后端服务器没有 /home 对应的接口，那么就会返回404。

- 生产环境 刷新 404 的解决办法可以在 nginx 做代理转发，在 nginx 中配置按顺序检查参数中的资源是否存在，如果都没有找到，让 nginx 内部重定向到项目首页(回退操作)。

- 开发模式下不会出现得原因：经查阅相关资料后发现在 vue-cli 中 webpack 帮我们做了处理，如果我们把该配置改位 false,浏览器会把我们这个当做是一次 get 请求，如果后端没有对应的接口,就会出现下面这个报错提示。


#### 回答：
- vue-router 有 3 个模式，其中 history 和 hash 更常用，两者差别主要在显示形式和部署上
- hash 模式在地址栏显示的时候就是哈希的形式，这种方式使用和部署比较简单；history 模式url看起来更优雅美观，但是应用在部署时需要做特殊配置，web服务器需要做回退处理（下面的 history 部署问题 部分），否则会出现 404 问题
- 不管那种模式，都是通过监听 popState事件触发路由跳转处理，url 显示不同只是显示效果上的差异。

#### history 部署问题：
history 在做部署的时候一定要做一些特殊的配置，否者会出现刷新 404 等问题：
```js
server {
  listen: 80;
  server_name xxx.com;

  // 当在 admin 路径下刷新时就会由这个来处理，但是 ningx 不能处理 /admin/xxxx/xxx 这种是处理不了的
  location /admin {
    root /Users/abc/www/admin;
    index index.html;
    // 核心部分（回退处理）：先匹配 文件（$uri） 然后是路径（$uri） 最后是都没匹配上就跳转到跟地址（index.html） 防止匹配不上时出现 404
    try_files $uri $uri/ admin/index.html; 
  }
}
```


##### 你刚刚提到 history 模式下刷新会出现 404 ，为什么？然后为什么 hash 模式下就不会？
是这样子的，首先 history 输入的是一个完整的路径，所以如果在后面加 /xxx/xxx 浏览器就会带上这个路径到服务端，可以是如果服务端没有这个路径所以就会出现 404，因此在服务端配置 ngnix 进行代理，进行回退操作即可避免出现 404。然后 hash 模式是监听 # 后面的值的，所以尽管再怎么刷新请求服务端的资源路径是不会变得，因为 # 后面得值不影响请求服务端资源得路径（# 后面得值进行请求时不会带上）